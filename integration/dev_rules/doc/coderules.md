[< Содержание](/README.md)
# Правила оформления кода

## Оформление модулей

- Длина строки в общем случае не должна превышать 120 символов.
- Для отступов необходимо использовать символы табуляции.
- Одна строка кода - одна управляющая конструкция. Следует  избегать однострочных конструкций, содержащих сложную логику
 
```bsl
// Неправильно:
Если ЭтоБрак Тогда Продолжить; КонецЕсли;

// Правильно:
Если ЭтоБрак Тогда
  Продолжить;
КонецЕсли;

// Неправильно:
Возврат Запрос.Выполнить().Выгрузить().Свернуть("Ссылка").ВыгрузитьКолонку("Ссылка")

//Правильно
РезультатЗапроса = Запрос.Выполнить();
ДанныеЗапроса = РезультатЗапроса.Выгрузить();

Возврат ДанныеЗапроса.Свернуть("Ссылка").ВыгрузитьКолонку("Ссылка")

```

* Программный код любого метода не должен превышать 200 строк. Для этого следует определить задачи и подзадачи, которые он выполняет, и попробовать вынести подзадачи в отдельный метод
Исключения: методы, которые возвращают тексты запросов или какие-либо другие объемные строковые фрагменты

* Использование областей внутри процедуры или функции недопустимо

* Текст запроса должен быть оформлен отдельной функцией

* Следует отделять друг от друга пробелами ключевые слова, вызовы процедур и функций, параметры процедур и функций внутри скобок, операторы.

```bsl
// Неправильно:
Сообщить(“Сумма: “+Сумма);

// Правильно:
Сообщить(“Сумма: “ + Сумма);
```

- Для разделения на логические части внутри модуля следует использовать пустые строки
- При вызове функции с несколькими параметрами при переносе строк необходимо выравнивать параметры по первому

```bsl
// Начальное состояние (строка слишком длинная):
НалоговыйУчет.ОстаткиВременныхРазниц(СтрокаВидАктиваОбязательства, СписокОрганизаций, Реквизиты.НачалоГода, Реквизиты.КонДата);

// Неправильно:
НалоговыйУчет.ОстаткиВременныхРазниц(
    СтрокаВидАктиваОбязательства, СписокОрганизаций, Реквизиты.НачалоГода, Реквизиты.КонДата);

// Лучше:
НалоговыйУчет.ОстаткиВременныхРазниц(СтрокаВидАктиваОбязательства,
                                     СписокОрганизаций,
                                     Реквизиты.НачалоГода,
                                     Реквизиты.КонДата
);

// Правильно:
НалоговыйУчет.ОстаткиВременныхРазниц(
    СтрокаВидАктиваОбязательства,
    СписокОрганизаций,
    Реквизиты.НачалоГода,
    Реквизиты.КонДата
);
    
```

* Выравнивание однотипных операторов. При следовании друг за другом нескольких однотипных операторов допускается их выравнивание. Выравнивание следует выполнять с помощью пробелов

```bsl
// Правильно:
НоваяСтрока = ВидыОпераций.Добавить();
НоваяСтрока.ВидОперации         = ВидОперации;
НоваяСтрока.НомерГруппы         = ГруппаПоВидуОперации(ВидОперации);
НоваяСтрока.ПоОрганизацииВЦелом = ГруппаПоОрганизации(НоваяСтрок);
```

* Управляющие конструкции не должны быть вложены слишком глубок (цикломатическая сложность). Уровень вложенности должен быть менее 5.

> Вложенные операторы "Если, "Для", "Для Каждого", "Пока" и "Попытка" являются ключевыми ингредиентами для создания так называемого "спагетти-кода".

Неправильно:
```bsl
Если Чтото Тогда                  // Допустимо - уровень = 1
  /* ... */
  Если ЧтоТоЕще Тогда             // Допустимо - уровень = 2
    /* ... */
    Для Ном = 0 По 10 Цикл          // Допустимо - уровень = 3
      /* ... */
      Если ОпятьУсловие Тогда       // Допустимо - уровень = 4, лимит достигнут, но не превышен
        Если ЕщеЧтото Тогда        // Уровень = 5, Превышен лимит
          /* ... */
        КонецЕсли;
        Возврат;
      КонецЕсли;
    КонецЦикла;
  КонецЕсли;
КонецЕсли;

```
* Когнитивная сложность метода должна быть менее 15

> Когнитивная сложность показывает на сколько сложно воспринимать написанный код.
Высокая когнитивная сложность явно указывает на необходимость проведения рефакторинга кода для облегчения его будущей поддержки.
Наиболее эффективным способом снижения когнитивной сложности является декомпозиция кода, дробление методов на более простые, а также оптимизация логических выражений.

Ниже приведены правила анализа когда, условия повышения когнитивной сложности:

```bsl
// Цикл `Для каждого`
Для каждого Элемент Из Коллекция Цикл                // +1
КонецЦикла;

// Цикл `Для`
Для Ит = Начало По Конец Цикл                        // +1
КонецЦикла;

// Цикл `Пока`
Пока Условие Цикл                                    // +1
КонецЦикла;


// Условие
Если Условие Тогда                                   // +1

// Альтернативная ветвь условия
ИначеЕсли Условие2 Тогда                             // +1

// Ветвь по-умолчанию
Иначе
КонецЕсли;

// Тернарный оператор
Значение = ?(Условие, ЗначениеИстина, ЗначениеЛожь); // +1

Попытка
// Обработка исключения
Исключение                                           // +1
КонецПопытки;

// Переход на метку
Перейти ~Метка;                                      // +1

// Бинарные логические операции

Пока Условие ИЛИ Условие2 Цикл                       // +2
КонецЦикла;

Если Условие И Условие2 Тогда                        // +2

ИначеЕсли Условие2                                   // +1
        ИЛИ Условие3 И Условие4 Тогда                // +2

КонецЕсли;

Значение = ?(Условие ИЛИ Условие2 ИЛИ НЕ Условие3,   // +3
                ЗначениеИстина, ЗначениеЛожь); 

Значение = Одно ИЛИ Второе;                          // +1

Значение = А <> B;                                   // +1

```

Ниже на примерах кода произведен рассчет когнитивной сложности методов.

```bsl

Функция Пример1(ТипКласса)
    Если ТипКласса.Неизвестен() Тогда                                                  // +1, условие, //вложенности нет
        Возврат Символы.НеизвестныйСимвол;
    КонецЕсли;

    НеизвестностьНайдена = Ложь;
    СписокСимволов = ТипКласса.ПолучитьСимвол().Потомки.Поиск("имя");
    Для Каждого Символ Из СписокСимволов Цикл                                          // +1, цикл, вложенности нет
        Если Символ.ИмеетТип(Символы.Странное)                                         // +2, условие вложенное в цикл, вложенность 1
            И НЕ Символы.Экспортный() Тогда                                            // +1, логическая перация, вложенность не учитывается

            Если МожноПереопределить(Символ) Тогда                                     // +3, вложенное условие, вложенность 2
                Переопредялемость = ПроверитьПереопределяемость(Символ, ТипКласса);
                Если Переопределяемость = Неопределено Тогда                           // +4, вложенное условие, вложенность 3
                    Если НЕ НеизвестностьНайдена Тогда                                 // +5, вложенное  условие, вложенность 4
                        НеизвестностьНайдена = Истина;
                    КонецЕсли;
                ИначеЕсли Переопределяемость Тогда                                     // +1, альтернативная ветвь условия, вложенность не учитывается
                    Возврат Символ;
                КонецЕсли;
            Иначе                                                                      // +1, ветвь по-умолчанию, вложенность не учитывается
                Продолжить;
            КонецЕсли;
        КонецЕсли;
    КонецЦикла;

    Если НеизвестностьНайдена Тогда                                                   // +1, вложенности нет
        Возврат Символы.НеизвестныйСимвол;
    КонецЕсли;

    Возврат Неопределено;
КонецФункции

Функция Пример2(Документ)
    НачатьТранзакцию();
    НадоПровести = ?(Документ.Проведен, ЛОЖЬ,                                                        // +1, тернарный оператор
                                        ?(Документ.ПометкаУдаления, ЛОЖЬ, ИСТИНА));                  // +2, вложенный тернарный оператор, вложенность 1
    Попытка                                                                                          // +0, попытка, повышает уровень вложенности
        ДокументОбъект = Документ.ПолучитьОбъект();
        Если ДокументОбъект.Проведен Тогда                                                           // +2, вложенное условие, вложенность 1
            Для Каждого СтрокаТабличнойЧасти Из ДокументОбъект.ТабличнаяЧасть Цикл                   // +3, вложенный цикл, вложенность 2
                Если СтрокаТабличнойЧасти.Колонка1 = 7                                               // +4, вложенное условие, вложенность 3
                        ИЛИ СтрокаТабличнойЧасти.Колонка2 = 7 Тогда                                  // +1, логическая операция, вложенность не учитывается
                    Продолжить;
                КонецЕсли;
                Если СтрокаТабличнойЧасти.Колонка4 > 1 Тогда                                         // +4, вложенное условие, вложенность 3
                    Прервать;
                Иначе                                                                                // +1, ветвь по-умолчанию, вложенность не учитывается
                    Если СтрокаТабличнойЧасти.Колонка1 + СтрокаТабличнойЧасти.Колонка2 = 2 Тогда     // +5, вложенное условие, вложенность 4
                        СтрокаТабличнойЧасти.Колонка10 = СтрокаТабличнойЧасти.Колонка1 * 2;
                    КонецЕсли;
                КонецЕсли;
            КонецЦикла;
        Иначе                                                                                        // +1, ветвь по-умолчанию, вложенность не учитывается
            НадоПровести = ДокументОбъект.Дата > ТекущаяДата();                                      // +1, логическая операция, вложенность не учитывается
            Перейти ~Метка;                                                                          // +1, переход на метку, вложенность не учитывается
        КонецЕсли;

        Если НадоПровести Тогда                                                                      // +2, вложенное условие, вложенность 1
            ДокументОбъект.Записать(РежимЗаписиДокумента.Проведение);
        ИначеЕсли НЕ НадоПровести Тогда                                                              // +1, альтернативная ветвь, вложенность не учитывается
            ДокументОбъект.Записать(РежимЗаписиДокумента.Запись);
        Иначе                                                                                        // +1, ветвь по-умолчанию, вложенность не учитывается
            ВызватьИсключение "Как так-то?";
        КонецЕсли;
    Исключение                                                                                       // +1, обработка исключения
        ПовторнаяЗапись = ЛОЖЬ;
        Попытка                                                                                      // +0, попытка, повышает уровень вложенности
            Если ДокументОбъект.Проведен Тогда                                                       // +3, вложенное условие, вложенность 2
                ДокументОбъект.Записать(РежимЗаписиДокумента.Запись);
            КонецЕсли;
        Исключение                                                                                   // +2, обработка исключения, вложенность 1
            ПовторнаяЗапись = ИСТИНА;
        КонецПопытки;
        Если Не ПовторнаяЗапись Тогда                                                                // +2, вложенное условие, вложенность 1
            Пока ТранзакцияАктина() Цикл                                                             // +3, вложенный цикл, вложенность 2
                ОтменитьТранзакцию();
            КонецЦикла;
        КонецЕсли;
        ВызватьИсключение "Ошибка"
    КонецПопытки;

    ~Метка:
    Возврат Неопределено;
КонецФункции
```

### Методы

* Процедура или функция должна содержать текстовую аннотацию, раскрывающую назначение и особенности эксплуатации метода. Также в аннотации должны быть перечислены и описаны все параметры метода и все варианты возвращаемого значения, если метод технически является функцией. 

Комментарий размещается перед объявлением процедуры (функции) и имеет следующий вид:
> Секция "Описание" содержит описание назначения процедуры (функции), достаточное для понимания сценариев ее использования без просмотра ее исходного кода. Также может содержать краткое описание принципов работы и перекрестные ссылки на связанные процедуры и функции.
>
> Может быть единственной секцией для процедур без параметров. Описание не должно совпадать с именем процедуры (функции). Для процедур и функций секция должна начинаться с глагола. Для функций это, как правило: «Возвращает…». В тех случаях, когда возвращаемый результат является не основным в работе функции, – то с основного действия, например: «Проверяет…», «Сравнивает…», «Вычисляет…» и т.п. Не рекомендуется начинать описание с избыточных слов «Процедура...», «Функция...», а также с имени самой процедуры (функции), от удаления которых смысл не меняется.

Неправильно:
```bsl
// Конструктор объекта WSПрокси.
// ...
Функция WSПрокси(ПараметрыПрокси) Экспорт

// Функция СтрокаТаблицыЗначенийВСтруктуру создает структуру со свойствами, соответствующими...
Функция СтрокаТаблицыЗначенийВСтруктуру(СтрокаТаблицыЗначений) Экспорт
```

Правильно:
```bsl
// Создает прокси на основе определения веб-сервиса и связывает
// его с точкой подключения веб-сервиса.
// В дополнении к платформенному конструктору Новый WSПрокси:
//  - включает в себя вызов конструктора WSОпределения;
//  - на время сеанса кэширует файл WSDL для оптимизации частых обращений к веб-сервису;
//  - не требует явного указания ИнтернетПрокси (он подставляется автоматически, если настроен);
//  - выполняет быструю проверку доступности веб-сервиса с помощью операции Ping.
// ...
Функция WSПрокси(ПараметрыПрокси) Экспорт

// Создает структуру со свойствами, соответствующими...
Функция СтрокаТаблицыЗначенийВСтруктуру(СтрокаТаблицыЗначений) Экспорт
```

> Секция "Параметры" описывает параметры процедуры (функции). Если их нет, секция пропускается. Предваряется строкой "Параметры:", затем с новой строки размещаются описания всех параметров.
>
> Имя параметра необходимо стремиться выбирать таким образом, чтобы его назначение было понятно в контексте функции без дополнительных пояснений
>
> Описание типа является обязательным. Тип может быть описан явно, при этом может быть указан или один тип или список типов. Под «списком типов» подразумеваются имена типов, разделенные запятыми. Имя типа может быть простым (в одно слово) или составным - в два слова, разделенных точкой. 
Например: Строка, Структура, Произвольный, СправочникСсылка.Сотрудники.
>
> В качестве типов значений следует использовать только существующие в платформе типы, а также специальные типы: ОпределяемыйТип.<Имя>, СправочникСсылка, ОбъектМетаданныхОтчет, РасширениеДекорацииФормыДляНадписи и т.п.

Неправильно:

```bsl
// КоллекцияСтрок - КоллекцияЗначений – коллекция для сравнения;
// ФормируемыйОтчет - ОбъектМетаданных: Отчет
// ПрисоединенныйФайлОбъект - элемент справочника файлов.
```

Правильно:

```bsl
// КоллекцияСтрок – ТаблицаЗначений, Массив, СписокЗначений – коллекция для сравнения.
// ФормируемыйОтчет – ОбъектМетаданныхОтчет
// ПрисоединенныйФайлОбъект - ОпределяемыйТип.ПрисоединенныйФайлОбъект - элемент справочника файлов.
```
> Текстовое описание параметра рекомендуется заполнять в том случае, когда только имени параметра в контексте функции не достаточно для понимания его назначения, либо требуется дать дополнительную информацию о типе, поясняющие назначение параметра, а также может приводиться наглядный пример с ожидаемым значением параметра.

> Для параметров типа Структура и ТаблицаЗначений также задается описание их свойств и колонок, которые начинаются с новой строки и предваряются символом *. 

Например:

```bsl
// Параметры:
//   СтатусыСерий - ТаблицаЗначений:
//     * Серия - СправочникСсылка.СерииНоменклатуры - если серия указана и она может
//               использоваться с новым значением номенклатуры на указанном складе, 
//               то возвращается переданное значение; если нет - пустая ссылка
//     * СтатусУказанияСерий - Число - если серии указываются в ТЧ "Товары", то 
//               возвращается рассчитанный статус, если для переданной
//               номенклатуры/склада серии не используется - возвращается 0
//               иначе возвращается переданный статус.
```

> Для параметров типа Массив следует указывать тип элементов с помощью ключевого слова "из" 

> В описании массивов, структур и таблиц значений могут быть вложенные описания, при этом перед именами вложенных свойств число звездочек увеличивается: для первого уровня вложенности 2 звездочки, для второго 3 и т.д.

```bsl
// Параметры:
//  СведенияОбОбновлении - Массив из Структура:
//     * КодАдресногоОбъекта - Структура:
//        ** КодРегиона             - Число - код региона (длина - 2).
//        ** КодНаселенногоПункта   - Число - код населенного пункта (длина - 3).
//        ** КодУлицы               - Число - код улицы (длина - 4).
//     * Наименование        - Строка
//     * ОбновлениеДоступно  - Булево
//
```

> Секция "Возвращаемое значение" описывает тип и содержание возвращаемого значения функции. Для процедур эта секция отсутствует. Предваряется строкой "Возвращаемое значение:". Затем с новой строки тип возвращаемого значения, дефис и текст описания. При использовании возвращаемого значения составного типа следует каждый тип писать с новой строки и с дефиса. 

```bsl
// Возвращаемое значение:
//  Строка

// Возвращаемое значение:
//  Булево - Истина, если хотя бы одна из переданных ролей доступна текущему пользователю, либо у него есть административные права.

// Возвращаемое значение: 
//  - ЛюбаяСсылка - ссылка на предопределенный элемент.
//  - Неопределено - если предопределенный элемент есть в метаданных, но не создан в ИБ.

// Возвращаемое значение:
//  - СправочникСсылка.Пользователи
//  - СправочникСсылка.ВнешниеПользователи
```

* Параметры любой процедуры или функции подразделяются на основные и дополнительные. Основные параметры передаются классическим образом, как параметры, дополнительные параметры передаются в виде структуры. Количество основных параметров любого метода не должно превышать трех. Структура дополнительных параметров таким образом является четвертым параметром. Для первоначальной инициализации структуры дополнительных параметров необходимо создать функцию конструктор. Описание ключей структуры должно быть в заголовке процедуры или функции.  

Пример функции-конструктора параметров в модуле ЦенообразованиеКлиентСервер:

```bsl
Функция ПараметрыЗаполненияЦеныВСтрокеТЧ() Экспорт
 
 ПараметрыЗаполненияЦен = Новый Структура;
 ПараметрыЗаполненияЦен.Вставить("Дата");
 ПараметрыЗаполненияЦен.Вставить("Валюта");
 ПараметрыЗаполненияЦен.Вставить("ПересчитыватьСумму", Истина);
 ПараметрыЗаполненияЦен.Вставить("ОбязательныеПараметры","Дата,Валюта"); // обязательные параметры, которые нужно заполнять
 Возврат ПараметрыЗаполненияЦен;
 
КонецФункции
```

> Имена свойств структуры соответствуют параметрам вызываемой функции. При этом параметры со значениями по умолчанию должны быть явно проинициализированы в этой структуре.
>
> В вызывающем коде не следует инициализировать структуру параметров или добавлять в нее какие-либо другие свойства. Во избежание неоднозначности и скрытых ошибок все допустимые параметры вызываемой функции должны быть определены явно в функции-конструкторе параметров.

- Параметр функции не должен возвращать значение. Иными словами не используйте входные параметры функций как дополнительный вывод. Весь вывод должен быть в возвращаемом значении. Если нужно возвращать несколько значений следует использовать такие типы как `Структура`, `Массив` и т.д.
```bsl
// Плохо:
URLСервиса = "";
ИмяПользователя = "";
ПарольПользователя = "";

ЗаполнитьПараметрыПодключения(URLСервиса, ИмяПользователя, Пароль);

// Хорошо:
ПараметрыПодключения = ПолучитьПараметрыПодключения();
// Возвращаемое значение - структура:
//     URLСервиса         - Строка
//     ИмяПользователя    - Строка
//     ПарольПользователя - Строка
```

### Условия

- Предпочтительней использовать тернарный оператор для простых конструкций.
```bsl
// Неправильно:
Если НДС0 Тогда
    Возврат 0;
Иначе
    Возврат 18;
КонецЕсли;

// Правильно:
Возврат ?(НДС0, 0, 18);
```

- Не допускайте использования вложенных тернарных операторов.
- Ключевое слово `Тогда` пишется на той же строке, что и последнее условие.
- Сложные условия (содержащие 3  конструкции и более) необходимо выносить в отдельные методы.

```bsl
// Неправильно:
Если ИдентификаторОбъекта = "АнализСубконто"
    ИЛИ ИдентификаторОбъекта = "АнализСчета"
    ИЛИ ИдентификаторОбъекта = "ОборотноСальдоваяВедомость"
    ИЛИ ИдентификаторОбъекта = "ОборотноСальдоваяВедомостьПоСчету"
    ИЛИ ИдентификаторОбъекта = "ОборотыМеждуСубконто"
    ИЛИ ИдентификаторОбъекта = "ОборотыСчета"
    ИЛИ ИдентификаторОбъекта = "СводныеПроводки" 
    ИЛИ ИдентификаторОбъекта = "ГлавнаяКнига"
    ИЛИ ИдентификаторОбъекта = "ШахматнаяВедомость" Тогда
    ПараметрыРасшифровки.Вставить("ОткрытьОбъект", Ложь);
		
    ЕстьПоказатель  = Ложь;
    ЕстьКорЗначение = Ложь;
    ЕстьСчет        = Истина;
    Счет            = Неопределено;
    ПервыйЭлемент   = Неопределено;

КонецЕсли;

// Правильно:
Если ОткрыватьОбъектПриИдентификаторе(ИдентификаторОбъекта) Тогда

    ПараметрыРасшифровки.Вставить("ОткрытьОбъект", Ложь);
		
    ЕстьПоказатель  = Ложь;
    ЕстьКорЗначение = Ложь;
    ЕстьСчет        = Истина;
    Счет            = Неопределено;
    ПервыйЭлемент   = Неопределено;
КонецЕсли;

//Вариант - 1
Функция ОткрыватьОбъектПриИдентификаторе(ИдентификаторОбъекта)
	
    Возврат ИдентификаторОбъекта = "АнализСубконто"
        ИЛИ ИдентификаторОбъекта = "АнализСчета"
        ИЛИ ИдентификаторОбъекта = "ОборотноСальдоваяВедомость"
        ИЛИ ИдентификаторОбъекта = "ОборотноСальдоваяВедомостьПоСчету"
        ИЛИ ИдентификаторОбъекта = "ОборотыМеждуСубконто"
        ИЛИ ИдентификаторОбъекта = "ОборотыСчета"
        ИЛИ ИдентификаторОбъекта = "СводныеПроводки" 
        ИЛИ ИдентификаторОбъекта = "ГлавнаяКнига"
        ИЛИ ИдентификаторОбъекта = "ШахматнаяВедомость";

КонецФункции

//Вариант - 2
Функция ОткрыватьОбъектПриИдентификаторе(ИдентификаторОбъекта)
	
    ИспользуемыеИдентификаторы = Новый Массив;
    ИспользуемыеИдентификаторы.Добавить("АнализСубконто");
    ИспользуемыеИдентификаторы.Добавить("АнализСчета");
    ИспользуемыеИдентификаторы.Добавить("ГлавнаяКнига");
    ИспользуемыеИдентификаторы.Добавить("ОборотноСальдоваяВедомость");
    ИспользуемыеИдентификаторы.Добавить("ОборотноСальдоваяВедомостьПоСчету");
    ИспользуемыеИдентификаторы.Добавить("ОборотыМеждуСубконто");
    ИспользуемыеИдентификаторы.Добавить("ОборотыСчета");
    ИспользуемыеИдентификаторы.Добавить("СводныеПроводки");
    ИспользуемыеИдентификаторы.Добавить("ШахматнаяВедомость");

    Возврат ИспользуемыеИдентификаторы.Найти(ИдентификаторОбъекта) <> Неопределено;

КонецФункции
```

* Избегайте использования больших блоков кода внутри операторов `Если`. Вместо этого выносить код реализации в отдельный метод.

Неправильно:
```bsl

Пока ВыборкаЗапроса.Слудующий() Цикл

    Если ДанныеВыборкиКорректны( ВыборкаЗапроса ) Тогда

        //... несколько стрниц кода

    Иначе

        //... несколько стрниц кода

    КонецЕсли;

КонецЦикла;
```

Правильно:
```bsl

Пока ВыборкаЗапроса.Слудующий() Цикл

    Если ДанныеВыборкиКорректны( ВыборкаЗапроса ) Тогда

        ВывестиДанныеВыборки( ВыборкаЗапроса )

    Иначе

        ДобавитьОшибкуВЛог( ВыборкаЗапроса )

    КонецЕсли;

КонецЦикла;
```

- Избегайте использование Йода-синтаксиса.
```bsl
// Неправильно:
Если 0 = Сумма Тогда

// Правильно:
Если Сумма = 0 Тогда
```

### Переменные

* Перечень строковых величин располагать в алфавитном порядке

Неправильно:

```bsl
ПараметрыОткрытия = Новый Структура( "Ссылка, Комментарий, Наименование, ПредставлениеУсловий
                                    |ПометкаУдаления, Пордяок, ГруппаТомов, НавигационнаяСсылка
                                    |УникальныйИдентификатор, Ответственный" ):
```

Правильно - вариант 1:

```bsl
ПараметрыОткрытия = Новый Структура( "ГруппаТомов, Комментарий, НавигационнаяСсылка,Наименование,                                               |Ответственный, ПометкаУдаления, Пордяок, ПредставлениеУсловий, 
                                    |Ссылка, УникальныйИдентификатор" ):
```
Правильно - вариант 2 лучше:

```bsl
ПараметрыОткрытия = Новый Структура;
ПараметрыОткрытия.Вставить( "ГруппаТомов" );
ПараметрыОткрытия.Вставить( "Комментарий" );
ПараметрыОткрытия.Вставить( "НавигационнаяСсылка" );
ПараметрыОткрытия.Вставить( "Наименование" );
ПараметрыОткрытия.Вставить( "Ответственный" );
ПараметрыОткрытия.Вставить( "ПометкаУдаления" );
ПараметрыОткрытия.Вставить( "Пордяок" );
ПараметрыОткрытия.Вставить( "ПредставлениеУсловий" );
ПараметрыОткрытия.Вставить( "Ссылка" );
ПараметрыОткрытия.Вставить( "УникальныйИдентификатор" );

```

* `Магические числа` необходимо заменять на символьные константы
> Магические числа — это значения, встречающиеся в коде, но при этом неочевидно, что они означают. 
> Это затрудняет понимание программы и усложняет её рефакторинг.


Неправильно: 
```bsl

Функция ПодключитьсяКСервису()

    Возврат МодульПодключенияКСервисуА.Подключиться( 60, Ложь )

КонецФункции

```

Правильно: 
```bsl

Функция ПодключитьсяКСервисуА()

    Таймаут = 60;
    ВызывтьИсключениеПриОшибке = Ложь;

    Возврат МодульПодключенияКСервисуА.Подключиться( Таймаут, ВызывтьИсключениеПриОшибке );

КонецФункции

```



### Имена процедур, функций, переменных

- Следуюйте общему подходу именования
```bsl
// Неправильно:
этобрак, ЭТОБРАК, этоБрак

// Правильно:
ЭтоБрак
```

- Не используйте отрицание в именах переменных и методов
```bsl
// Неправильно:
Функция ПроверкаНеПройдена()
...

Если Не (Условие И Не ПроверкаНеПройдена()) Тогда

// Правильно:
Функция ПроверкаПройдена()
...

Если Не Условие И Не ПроверкаПройдена() Тогда
```

## Создание, изменение объектов метаданных

- Если составной тип используется многократно, следует использовать объект конфигурации "Определяемый тип". Пример: "Документ резервирования", "Документ партии".

