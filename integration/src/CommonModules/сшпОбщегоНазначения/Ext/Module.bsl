
#Область ПрограммныйИнтерфейс

//Функция - Получить структуру адреса информационной базы
//
//Возвращаемое значение:
//  Структура - адрес информационной базы: Адрес, Порт, ИмяБазы
//
Функция ПолучитьСтруктуруАдресаИБ() Экспорт
	
	ДанныеСтрокиСоединения = СтрРазделить(СтрокаСоединенияИнформационнойБазы(), ";");
	Если Не ДанныеСтрокиСоединения.Количество() = 3 Тогда
		ВызватьИсключение "Работа с файловыми информационными базами не поддерживается"; 
	КонецЕсли;
	
	ИмяБазы      = Сред(ДанныеСтрокиСоединения[1], 6, СтрДлина(ДанныеСтрокиСоединения[1]) - 6);
	АдресСервера = Сред(ДанныеСтрокиСоединения[0], 7, СтрДлина(ДанныеСтрокиСоединения[0]) - 7);
	
	ДанныеАдресаСервера = СтрРазделить(АдресСервера, ":");
	
	Результат = Новый Структура;
	Результат.Вставить("Адрес", ИмяКомпьютера());
	Если ДанныеАдресаСервера.Количество() > 1 тогда
		Результат.Вставить("Порт", XMLЗначение(Тип("Число"), СокрЛП(ДанныеАдресаСервера[1]))) 
	Иначе 
		Результат.Вставить("Порт", 1541);
	КонецЕсли;	
	Результат.Вставить("ИмяБазы", СокрЛП(ИмяБазы));
	
	Возврат Результат;
	
КонецФункции

// Получает структуру с идентификатором объекта 
// 
// Параметры:
// 	ОбъектСобытия - Произвольный - Идентификатор объекта
// Возвращаемое значение:
// 	Структура - Описание:
// * Object1cId - Строка - Идентификатор объекта
//
Функция ПолучитьИдентификаторОбъектаСобытия(ОбъектСобытия) Экспорт
	
	Идентификатор = "";
	
	Если Не ТипЗнч(ОбъектСобытия) = Тип("Отбор")
			И Не ТипЗнч(ОбъектСобытия) = Тип("Структура")
			И Не ТипЗнч(ОбъектСобытия) = Тип("Строка") Тогда

		Попытка

			Идентификатор = Строка(ОбъектСобытия.УникальныйИдентификатор());

		Исключение

			ЗаписьЖурналаРегистрации("Datareon. Не удалось получить идентификатор объекта", УровеньЖурналаРегистрации.Ошибка, , , "Не удалось получить идентификатор объекта, по причине: "
				+ ОписаниеОшибки());

		КонецПопытки;

	КонецЕсли;
		
	ДопСвойства = Новый Структура;
	ДопСвойства.Вставить("Object1cId", Строка(Идентификатор));
	
	Возврат ДопСвойства;
	
КонецФункции

// Функция - Получить объект XDTO
//
// Параметры:
//  ФорматСообщения - Перечисление.сшпФорматыСообщений - текущий формат сообщения.
//  ТелоСообщения - Строка - Текстовое представление сообщения в указанном формате.
// 
// Возвращаемое значение:
//  ОбъектXDTO - объект сформированный фабрикойXDTO из исходного текста. В случае невозможности преобразования возвращается Неопределено.  
//
Функция ПолучитьОбъектXDTO(ФорматСообщения, ТелоСообщения, ТипОбъекта = Неопределено) Экспорт
	
	ТекОбъект = Неопределено;
	
	Попытка
		
		ТекЧтение = ПолучитьОбъектПотоковогоЧтения(ФорматСообщения, ТелоСообщения);
		
		Если Не ТекЧтение = Неопределено Тогда
		
			ТекОбъект = ПрочитатьОбъектИзПотока(ФорматСообщения, ТекЧтение, ТипОбъекта);
			
		КонецЕсли;
		
	Исключение
		
		Если Не ЗначениеЗаполнено(ТелоСообщения) Тогда
			
			ЗаписьЖурналаРегистрации("Datareon.ПолучитьОбъектСообщения", УровеньЖурналаРегистрации.Ошибка, , , "Не удалось получить объект XDTO, поле Body не содержит значения!");
			
		Иначе
			
			ИнформацияОбОшибке = ИнформацияОбОшибке();
			ЗаписьЖурналаРегистрации("Datareon.ПолучитьОбъектСообщения", УровеньЖурналаРегистрации.Ошибка, Метаданные.ОбщиеМодули.сшпОбщегоНазначения, , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке));
			
		КонецЕсли;
		
	КонецПопытки;
	
	Возврат ТекОбъект;
	
КонецФункции	

// Функция - Сформировать сообщение ESB
//
// Параметры:
//  Фабрика - ФабрикаXDTO - фаббрика которая содержит необходимые форматы сообщений. Для отправкии сообщений другим системам необходимо использовать фабрику полученную из текущего прокси-соединения.
//  Пакет - Структура - Структура содержащая поля соответствующие описанию формата объекта Message1C.
// 
// Возвращаемое значение:
//  ОбъектXDTO - обект типа Message1C.
//
Функция СформироватьСообщениеESB(Фабрика, Пакет) Экспорт
	
	ТипСообщение = Фабрика.Тип("http://esb.axelot.ru", "Message");
	
	Если ТипЗнч(Пакет) = Тип("Массив") Тогда
		 
		ТипПакета = Фабрика.Тип("http://esb.axelot.ru", "Messages");
		XdtoПакет = Фабрика.Создать(ТипПакета);
		
		Для Каждого Сообщение Из Пакет Цикл 
			
			XdtoСообщение = Фабрика.Создать(ТипСообщение);
			ЗаполнитьПакетXDTO(Фабрика, XdtoСообщение, Сообщение);
			XdtoПакет.Message.Добавить(XdtoСообщение);
		
		КонецЦикла;
	
	Иначе
		
		XdtoПакет = Фабрика.Создать(ТипСообщение);
		ЗаполнитьПакетXDTO(Фабрика, XdtoПакет, Пакет);
	
	КонецЕсли;

	Возврат XdtoПакет;
	
КонецФункции

Процедура ЗаполнитьПакетXDTO(Фабрика, XdtoПакет, Сообщение)
	
	XdtoПакет.Id 					= Фабрика.Создать(Фабрика.Тип("http://schemas.microsoft.com/2003/10/Serialization/", "guid"), Строка(Сообщение.Id));
	XdtoПакет.ClassId 				= Сообщение.ClassId;
	XdtoПакет.Type					= Сообщение.Type;
	XdtoПакет.CreationTime			= ?(Сообщение.CreationTime = Неопределено, ТекущаяДата(), Сообщение.CreationTime);
	XdtoПакет.Body 					= Сообщение.Body;		
	XdtoПакет.NeedAcknowledgment	= Сообщение.NeedAcknowledgment;
	XdtoПакет.ReplyTo 				= Сообщение.ReplyTo;
	XdtoПакет.Source 				= Сообщение.Source;	
	XdtoПакет.CorrelationId 		= ?(ЗначениеЗаполнено(Сообщение.CorrelationId), Фабрика.Создать(Фабрика.Тип("http://schemas.microsoft.com/2003/10/Serialization/", "guid"), Строка(Сообщение.CorrelationId)), Неопределено);
	XdtoПакет.Properties 			= Фабрика.Создать(Фабрика.Тип("http://esb.axelot.ru", "ArrayOfMessageProperty"));
	
	Если ТипЗнч(Сообщение.Properties) = Тип("Структура") Тогда
		
		Для Каждого Свойство Из Сообщение.Properties Цикл
			
			XdtoПакет.Properties.MessageProperty.Добавить(ДобавитьСвойствоСообщения(Фабрика, Свойство.Ключ, Свойство.Значение));
		
		КонецЦикла;	
	
	КонецЕсли;
	
	Если ТипЗнч(Сообщение.Receivers) = Тип("Массив") И Сообщение.Receivers.Количество() Тогда
		 
		XdtoПакет.Receivers = Фабрика.Создать(Фабрика.Тип("http://esb.axelot.ru", "Receivers"));
		
		Для Каждого ЭлементМассива Из Сообщение.Receivers Цикл 
			
			XdtoПакет.Receivers.Receiver.Добавить(ЭлементМассива);
		
		КонецЦикла;
	Иначе
		
		XdtoПакет.Receivers = Фабрика.Создать(Фабрика.Тип("http://esb.axelot.ru", "Receivers"));
	
	КонецЕсли;
	
КонецПроцедуры

// Функция - Добавить свойство сообщения
//
// Параметры:
//  Имя - Строка - Имя свойства 
//  Значение - Число,Строка,Булево - значение свойства. Поддерживаются примитивные типы. 
// 
// Возвращаемое значение:
//  ОбъектXDTO - объект XDTO с типом MessageProperty.
//
Функция ДобавитьСвойствоСообщения(Фабрика, Имя, Значение)
	
	xmlСтрока = "
	|<MessageProperty xmlns=""http://esb.axelot.ru"" xmlns:xs=""http://www.w3.org/2001/XMLSchema"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"">
	|	<Name>" + Имя + "</Name>
	|	<Value>
	|		" + ДобавитьЗначение(Значение) + "
	|	</Value>
	|</MessageProperty>";
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(XmlСтрока);
	
	Возврат Фабрика.ПрочитатьXML(ЧтениеXML, Фабрика.Тип("http://esb.axelot.ru", "MessageProperty"));
	
КонецФункции

// Функция - Добавить значение
//
// Параметры:
//  значение - Число,Строка,Булево - значение свойства. Поддерживаются примитивные типы .
// 
// Возвращаемое значение:
//  Строка - строка подстановки для формирования представления xml.
//
Функция ДобавитьЗначение(Значение)
	
	ТипЗначения = ТипЗнч(Значение);
	
	Если ТипЗначения = Тип("Число") Тогда
		
		Возврат ДобавитьЧисловоеЗначение(Значение);
		
	ИначеЕсли типЗначения = Тип("Строка") Тогда
		
		Возврат  ДобавитьСтроковоеЗначение(Значение);
		
	КонецЕсли;
		
	Возврат ДобавитьБулевоЗначение(Значение);
		
КонецФункции

// Функция - Добавить числовое значение
//
// Параметры:
//  Значение - Число - значение свойства.
// 
// Возвращаемое значение:
//  Строка - строка подстановки для формирования представления xml.
//
Функция ДобавитьЧисловоеЗначение(Значение)
	
	Возврат "
	|<IntegerValues>
	|	<int xmlns=""http://schemas.microsoft.com/2003/10/Serialization/Arrays"">" + XMLСтрока(Значение) + "</int>
	|</IntegerValues>
	|<Type>Integer</Type>";
	
КонецФункции

// Функция - Добавить строковое значение
//
// Параметры:
//  Значение - Строка - значение свойства.
// 
// Возвращаемое значение:
//  Строка - строка подстановки для формирования представления xml.
//
Функция ДобавитьСтроковоеЗначение(Значение)
	
	Возврат "
	|<StringValues>
	|	<string xmlns=""http://schemas.microsoft.com/2003/10/Serialization/Arrays"">" + XMLСтрока(ЗаменитьСпециальныеСимволы(Значение)) + "</string>
	|</StringValues>
	|<Type>String</Type>";
	
КонецФункции

// Функция - Добавить булево значение
//
// Параметры:
//  значение - Булево - значение свойства.
// 
// Возвращаемое значение:
//  Строка - строка подстановки для формирования представления xml.
//
Функция ДобавитьБулевоЗначение(Значение)
	
	Возврат "
	|<BooleanValues>
	|	<boolean xmlns=""http://schemas.microsoft.com/2003/10/Serialization/Arrays"">" + XMLСтрока(Значение) + "</boolean>
	|</BooleanValues>
	|<Type>Boolean</Type>";
	
КонецФункции

// Функция - Сформировать сообщение ESB HTTP
//
// Параметры:
//  Фабрика - ФабрикаXDTO - фаббрика которая содержит необходимые форматы сообщений. Для отправкии сообщений другим системам необходимо использовать фабрику полученную из текущего прокси-соединения.
//  Пакет - Структура - Структура содержащая поля соответствующие описанию формата объекта Message1C.
// 
// Возвращаемое значение:
//  Строка - ОбъектXDTO типа Message1C сериализованный в формат сообщения.
//
Функция СформироватьСообщениеESB_HTTP(Фабрика, Пакет) Экспорт
	
	xdtoПакет = СформироватьСообщениеESB(Фабрика, Пакет);
	
	Возврат ЗаписатьОбъектВПоток(Перечисления.сшпФорматыСообщений.XML, xdtoПакет, фабрика);
	
КонецФункции

// Функция - Преобразовать структуру по формату
//
// Параметры:
//  Формат - Перечисление.сшпФорматыСообщений - текущий формат сообщения
//  сткДанные - Структура - данные которые будут преобразованны в указанный формат.
// 
// Возвращаемое значение:
//  Строка - данные структуры преобразованные в указанный формат.
//
Функция ПреобразоватьСтруктуруПоФормату(Формат = Неопределено, СткДанные) Экспорт
	
	Если Формат = Неопределено Тогда
		
		Формат = сшпФункциональныеОпции.ФорматСообщения();
		
	КонецЕсли;
		
	Если Формат = Перечисления.сшпФорматыСообщений.XML Тогда
		
		Возврат сшпФункцииРаботыXML.СформироватьXML(СткДанные);
		
	ИначеЕсли Формат = Перечисления.сшпФорматыСообщений.JSON Тогда
		
		Возврат сшпФункцииРаботыJSON.СформироватьJSON(СткДанные);
		
	ИначеЕсли Формат = Перечисления.сшпФорматыСообщений.FastInfoset Тогда
		
		Возврат сшпФункцииРаботыFastInfoset.СформироватьFastInfoset(СткДанные);
		
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// Функция - Сериализовать объект
//
// Параметры:
//  Формат - Перечисление.сшпФорматыСообщений - текущий формат сообщения.
//  ОбъектИсточник - ЛюбаяСсылка, ЛюбойОбъект	 - объект который необходимо сериализовать в указанный формат.
// 
// Возвращаемое значение:
//  Строка - данные объекта преобразованные в указанный формат. 
//
Функция СериализоватьОбъект(Формат, ОбъектИсточник) Экспорт
	
	ТекОбъект = Неопределено;
	
	Попытка
	
		Если Формат = Перечисления.сшпФорматыСообщений.XML Тогда
	
			ТекОбъект = сшпФункцииРаботыXML.СериализоватьОбъект(ОбъектИсточник);
		
		ИначеЕсли Формат = Перечисления.сшпФорматыСообщений.JSON Тогда
		
			ТекОбъект = сшпФункцииРаботыJSON.СериализоватьОбъект(ОбъектИсточник);
		
		ИначеЕсли Формат = Перечисления.сшпФорматыСообщений.FastInfoset Тогда
		
			ТекОбъект = сшпФункцииРаботыFastInfoset.СериализоватьОбъект(ОбъектИсточник);
		
		КонецЕсли;
	
	Исключение
	
		ЗаписьЖурналаРегистрации("Datareon. Сериализация объекта", УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));		
	
	КонецПопытки;
	
	Возврат ТекОбъект;

КонецФункции	

// Функция - Десериализовать объект
//
// Параметры:
//  Формат - Перечисление.сшпФорматыСообщений - текущий формат сообщения.
//  ОбъектИсточник - Строка - описание объект в указанном формате.
// 
// Возвращаемое значение:
//  ЛюбаяСсылка, ЛюбойОбъект - объект десериализованный из указанного формата. 
//
Функция ДесериализоватьОбъект(Формат, ОбъектИсточник) Экспорт
	
	ТекОбъект = Неопределено;
	
	Попытка
		
		Если Формат = Перечисления.сшпФорматыСообщений.XML Тогда
			
			ТекОбъект = сшпФункцииРаботыXML.ДесериализоватьОбъект(ОбъектИсточник);
		
		ИначеЕсли Формат = Перечисления.сшпФорматыСообщений.JSON Тогда
			
			ТекОбъект = сшпФункцииРаботыJSON.ДесериализоватьОбъект(ОбъектИсточник);
		
		ИначеЕсли Формат = Перечисления.сшпФорматыСообщений.FastInfoset Тогда
			
			ТекОбъект = сшпФункцииРаботыFastInfoset.ДесериализоватьОбъект(ОбъектИсточник);
		
		КонецЕсли;
	
	Исключение
		
		ЗаписьЖурналаРегистрации("Datareon. Десериализация объекта", УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));		
	
	КонецПопытки;
	
	Возврат текОбъект;

КонецФункции	

// Функция - Получить объект потокового чтения
//
// Параметры:
//  Формат - Перечисление.сшпФорматыСообщений - текущий формат сообщения.
//  ЧитаемаяСтрока	 - 	 - .
// 
// Возвращаемое значение:
// ЧтениеXML, ЧтениеFastInfoset, ЧтениеJSON  - объект потокового чтения заданного формата.
//
Функция ПолучитьОбъектПотоковогоЧтения(Формат, ЧитаемаяСтрока) Экспорт
	
	ТекОбъект = Неопределено;
	
	Если Формат = Перечисления.сшпФорматыСообщений.XML Тогда
		
		ТекОбъект = сшпФункцииРаботыXML.ПолучитьОбъектПотоковогоЧтения(ЧитаемаяСтрока);
		
	ИначеЕсли Формат = Перечисления.сшпФорматыСообщений.JSON Тогда
		
		ТекОбъект = сшпФункцииРаботыJSON.ПолучитьОбъектПотоковогоЧтения(ЧитаемаяСтрока);
		
	ИначеЕсли Формат = Перечисления.сшпФорматыСообщений.FastInfoset Тогда
		
		ТекОбъект = сшпФункцииРаботыFastInfoset.ПолучитьОбъектПотоковогоЧтения(ЧитаемаяСтрока);
		
	КонецЕсли;
	
	Возврат ТекОбъект;
	
КонецФункции

// Функция - Получить объект потоковой записи
//
// Параметры:
//  Формат - Перечисление.сшпФорматыСообщений - текущий формат сообщения.
// 
// Возвращаемое значение:
// ЗаписьXML, ЗаписьFastInfoset, ЗаписьJSON  - объект потоковой записи заданного формата.
//
Функция ПолучитьОбъектПотоковойЗаписи(Формат) Экспорт
	
	ТекОбъект = Неопределено;
	
	Если Формат = Перечисления.сшпФорматыСообщений.XML Тогда
		
		ТекОбъект = сшпФункцииРаботыXML.ПолучитьОбъектПотоковойЗаписи();
		
	ИначеЕсли Формат = Перечисления.сшпФорматыСообщений.JSON Тогда
		
		ТекОбъект = сшпФункцииРаботыJSON.ПолучитьОбъектПотоковойЗаписи();
		
	ИначеЕсли Формат = Перечисления.сшпФорматыСообщений.FastInfoset Тогда
		
		ТекОбъект = сшпФункцииРаботыFastInfoset.ПолучитьОбъектПотоковойЗаписи();
		
	КонецЕсли;
	
	Возврат ТекОбъект;
	
КонецФункции	

// Функция - Прочитать объект из потока
//
// Параметры:
//  Формат - Перечисление.сшпФорматыСообщений - текущий формат сообщения.
//  Поток - Строка - строка описания объекта в заданном формате.
// 
// Возвращаемое значение:
//  ЛюбаяСсылка, ЛюбойОбъект - объект прочитанный фабрикой XDTO из указанного формата. 
//
Функция ПрочитатьОбъектИзПотока(Формат, Поток, ТипОбъекта) Экспорт
	
	ТекОбъект = Неопределено;
	
	Попытка
		
		Если Формат = Перечисления.сшпФорматыСообщений.XML Тогда
			
			ТекОбъект = сшпФункцииРаботыXML.ПрочитатьОбъектИзПотока(Поток, ТипОбъекта);
			
		ИначеЕсли Формат = Перечисления.сшпФорматыСообщений.JSON Тогда
			
			ТекОбъект = сшпФункцииРаботыJSON.ПрочитатьОбъектИзПотока(Поток, ТипОбъекта);
			
		ИначеЕсли Формат = Перечисления.сшпФорматыСообщений.FastInfoset Тогда
			
			ТекОбъект = сшпФункцииРаботыFastInfoset.ПрочитатьОбъектИзПотока(Поток, ТипОбъекта);
			
		КонецЕсли;
		
	Исключение
		
		ЗаписьЖурналаРегистрации("Datareon. Формирование объекта XDTO", УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));		
	
	КонецПопытки;
	
	Возврат ТекОбъект;

КонецФункции

// Функция - Записать объект в поток
//
// Параметры:
//  Формат - Перечисление.сшпФорматыСообщений - текущий формат сообщения.
//  Объект - ЛюбаяСсылка, ЛюбойОбъект - объект который необходимо сериализовать в указанный формат.
//  фабрика - ФабрикаXDTO - фабрика XDTO для преобразования объекта в строку указанного формата. 
// 
// Возвращаемое значение:
// Строка - Объект преобразованный в строку заданного формата.
//
Функция ЗаписатьОбъектВПоток(Формат, Объект, Фабрика = Неопределено) Экспорт
	
	СтрПредставление = "";
	
	Попытка
		
		Если Формат = Перечисления.сшпФорматыСообщений.XML Тогда
			
			СтрПредставление = сшпФункцииРаботыXML.ЗаписатьОбъектВПоток(Объект, Фабрика);
		
		ИначеЕсли Формат = Перечисления.сшпФорматыСообщений.JSON Тогда
			
			СтрПредставление = сшпФункцииРаботыJSON.ЗаписатьОбъектВПоток(Объект, Фабрика);
		
		ИначеЕсли Формат = Перечисления.сшпФорматыСообщений.FastInfoset Тогда
			
			СтрПредставление = сшпФункцииРаботыFastInfoset.ЗаписатьОбъектВПоток(Объект, Фабрика);
		
		КонецЕсли;
	
	Исключение
		
		ЗаписьЖурналаРегистрации("Datareon. Запись объекта XDTO в файл", УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));		
	
	КонецПопытки;
	
	Возврат СтрПредставление;

КонецФункции

// Процедура - Ожидание
//
// Параметры:
//  Длительность - Число - длительность ожидания в секундах.
//
Процедура Ожидание(Длительность) Экспорт
	
	ВнешняяКомпонента = сшпКэшируемыеФункции.ПолучитьКомпоненту();
	
	Если ВнешняяКомпонента = Неопределено Тогда 
		
		Идентификатор = Новый УникальныйИдентификатор;
		
		НачатьТранзакцию();
		
		Блокировка = Новый БлокировкаДанных;	
		Элемент = Блокировка.Добавить("РегистрСведений.сшпБлокировкаОчереди");
		Элемент.Режим = РежимБлокировкиДанных.Исключительный;
		Элемент.УстановитьЗначение("Идентификатор", Идентификатор);	
		Блокировка.Заблокировать();
		
		мсвПараметров = Новый Массив;
		мсвПараметров.Добавить(Идентификатор);
		
		Задание = ФоновыеЗадания.Выполнить("сшпОбщегоНазначения.ВыполнитьПаузу", мсвПараметров, , "Выполнить паузу " + Строка(Длительность) + " сек.");
		
		Попытка
			
			Задание.ОжидатьЗавершенияВыполнения(Длительность);
			
		Исключение
			
		КонецПопытки;             
		
		ОтменитьТранзакцию();
		
	Иначе
		
		ВнешняяКомпонента.Sleep(Длительность*1000);
		
	КонецЕсли;
	
КонецПроцедуры

// Процедура - Ожидание Мсек
//
// Параметры:
//  Длительность - Число - длительность ожидания в милисекундах.
//
Процедура ОжиданиеМСек(Длительность) Экспорт
	
	ВнешняяКомпонента = сшпКэшируемыеФункции.ПолучитьКомпоненту();
	
	Если ВнешняяКомпонента = Неопределено Тогда
		
		ОбщаяДлительность = ?(Окр(Длительность/1000, 0, РежимОкругления.Окр15как10) = 0, 1, Окр(Длительность/1000, 0, РежимОкругления.Окр15как10));
		
		Идентификатор = Новый УникальныйИдентификатор;
		
		НачатьТранзакцию();
		
		Блокировка = Новый БлокировкаДанных;	
		Элемент = Блокировка.Добавить("РегистрСведений.сшпБлокировкаОчереди");
		Элемент.Режим = РежимБлокировкиДанных.Исключительный;
		Элемент.УстановитьЗначение("Идентификатор", Идентификатор);	
		Блокировка.Заблокировать();
		
		мсвПараметров = Новый Массив;
		мсвПараметров.Добавить(Идентификатор);
		
		Задание = ФоновыеЗадания.Выполнить("сшпОбщегоНазначения.ВыполнитьПаузу", мсвПараметров, , "Выполнить паузу " + Строка(ОбщаяДлительность) + " сек.");
		
		Попытка
			
			Задание.ОжидатьЗавершенияВыполнения(ОбщаяДлительность);
			
		Исключение
			
		КонецПопытки;             
		
		ОтменитьТранзакцию();		
		
	Иначе
		
		ВнешняяКомпонента.Sleep(Длительность);		
		
	КонецЕсли;
	
КонецПроцедуры

// Процедура - Выполнить паузу
//
// Параметры:
//  Идентификатор - УникальныйИдентификатор - идентификатор сессии ожидания.
//
Процедура ВыполнитьПаузу(Идентификатор) Экспорт
	
	НачатьТранзакцию();
	
	Блокировка = Новый БлокировкаДанных;
	
	Элемент = Блокировка.Добавить("РегистрСведений.сшпБлокировкаОчереди");
	Элемент.Режим = РежимБлокировкиДанных.Исключительный;
	Элемент.УстановитьЗначение("Идентификатор", Идентификатор);
	
	Попытка
		
		Блокировка.Заблокировать();
		
	Исключение
		
	КонецПопытки;
	
	ОтменитьТранзакцию();
	
КонецПроцедуры

// Функция - Сформировать структуру пакета
//
// Параметры:
//  ТипПакета - Строка - тип информационного пакета. 
//  Класс - Строка - класс информационного пакета. 
//  ТелоПакета - Строка - секция Body информационного пакета. 
// 
// Возвращаемое значение:
// Структура - структура повторяющая структуру объекта XDTO типа Message1C.
//
Функция СформироватьСтруктуруПакета(ТипПакета = "DTP", Класс = "", ТелоПакета = "") Экспорт
	
	сткПакет = Новый Структура;
	сткПакет.Вставить("Id", Строка(Новый УникальныйИдентификатор));
	сткПакет.Вставить("Type", ТипПакета);
	сткПакет.Вставить("ClassId", Класс);
	сткПакет.Вставить("Body", ТелоПакета);
	сткПакет.Вставить("CreationTime", ТекущаяУниверсальнаяДата());
	сткПакет.Вставить("NeedAcknowledgment", Ложь);
	сткПакет.Вставить("Properties", Неопределено);
	сткПакет.Вставить("Receivers", Новый Массив);
	сткПакет.Вставить("ReplyTo", Неопределено);
	сткПакет.Вставить("Source", Неопределено);	
	сткПакет.Вставить("CorrelationId", Неопределено);	

	Возврат сткПакет;

КонецФункции

// Функция - Получить количество потоков
//
// Параметры:
//  ИмяПараметра - Строка - имя параметра по которому выполняется поиск фоновых заданий.
//  ЗначениеПараметра - Массив - значения для отбора по параметру.
// 
// Возвращаемое значение:
// Число  - количество активных фоновых заданий.
//
Функция ПолучитьКоличествоПотоков(ИмяПараметра, ЗначениеПараметра) Экспорт
	
	сткУсловияПоиска = Новый Структура;
	сткУсловияПоиска.Вставить(ИмяПараметра, ЗначениеПараметра);
	сткУсловияПоиска.Вставить("Состояние", СостояниеФоновогоЗадания.Активно);
	
	мсвОбработчики = ФоновыеЗадания.ПолучитьФоновыеЗадания(сткУсловияПоиска);
	
	Возврат мсвОбработчики.Количество();

КонецФункции	

// Процедура - Запустить обработку потоков
//
Процедура ЗапуститьОбработкуПотоков() Экспорт
	
	сшпОбщегоНазначения.ЗапуститьОбработчикОчереди("УправлениеПуломОбработчиков");
	
	РЗ = РегламентныеЗадания.НайтиПредопределенное(Метаданные.РегламентныеЗадания.сшпЗапускОбработкиЗаданий);
	
	Попытка
		
		ФоновоеЗадание = ФоновыеЗадания.Выполнить(РЗ.Метаданные.ИмяМетода, РЗ.Параметры, Строка(РЗ.УникальныйИдентификатор), РЗ.Наименование);
		
	Исключение
		
		//Уже запущено
		
	КонецПопытки;
	
КонецПроцедуры

// Функция - ПеревестиДатувЧисло
// 
// Возвращаемое значение:
// Число  - Дата изменения + Задержка.
//
Функция ПеревестиДатуВЧисло(ДатаИзменения, Задержка = 0) Экспорт
	
	Возврат (ДатаИзменения - Дата(2000,1,1)) + Задержка;
	
КонецФункции

#Если Сервер Тогда
	
// Функция - Проверить экземпляр информационной базы
// 
// Возвращаемое значение:
// Булево  - Результат проверки ИБ.
//
Функция ПроверитьЭкземплярИнформационнойБазы() Экспорт
	
	ЗначениеВозврат = Истина;
	БазовыйИдентификатор = сшпРаботаСКонстантами.ПолучитьЗначениеКонстанты("сшпИдентификаторИБ");
	
	СтруктураАдреса = ПолучитьСтруктуруАдресаИБ();
	
	Если ЗначениеЗаполнено(БазовыйИдентификатор) Тогда
		
		ЗначениеВозврат = БазовыйИдентификатор = НРег(СтруктураАдреса.ИмяБазы);
		
		Если ЗначениеВозврат Тогда
			ЗначениеВозврат = ПроверитьНастройкиКластера1С();
		КонецЕсли;
		
	Иначе
				
		сшпРаботаСКонстантами.УстановитьЗначениеКонстанты("сшпИдентификаторИБ", НРег(СтруктураАдреса.ИмяБазы));
		ПроверитьНастройкиКластера1С();
		
	КонецЕсли;
		
	Если Не ЗначениеВозврат Тогда
		
		сшпСистемныеСообщения.ОтправитьСообщениеОбОшибке("SUS", "Рассинхронизация идентификаторов информационной базы (база: " + НРег(СтруктураАдреса.ИмяБазы) + ", идентификатор: " + БазовыйИдентификатор + ")", Новый Структура());
		
	КонецЕсли;
		
	Возврат ЗначениеВозврат;
	
КонецФункции

&НаСервере
Функция ПроверитьНастройкиКластера1С() Экспорт
	
	СтруктураАдреса = сшпОбщегоНазначения.ПолучитьСтруктуруАдресаИБ();
	СтрокаПорт = Формат(СтруктураАдреса.Порт, "ЧГ=");
	
	СтруктураПоиска = новый Структура;
	СтруктураПоиска.Вставить("Адрес", СтруктураАдреса.Адрес);
	СтруктураПоиска.Вставить("Порт", СтрокаПорт);
	
	
	ТаблицаСервер1с = сшпРаботаСКонстантами.ПолучитьСервер1С();
	
	РезультатПоиска = ТаблицаСервер1с.НайтиСтроки(СтруктураПоиска);
	
	Если Не РезультатПоиска.Количество() Тогда
	
		Если Не ТаблицаСервер1с.Количество() ИЛИ 
				ТаблицаСервер1с.Количество() = 1 Тогда
			сшпРаботаСКонстантами.ЗаписатьЗначениеСтрокиСервера1С(СтруктураАдреса.Адрес, СтрокаПорт);
			Возврат Истина;
		Иначе
			ЗарегистрироватьЗаписьВЖурнале(УровеньЖурналаРегистрации.Ошибка, "Datareon.Рассинхронизация идентификаторов ИБ", "Имя текущего сервера " + СтруктураАдреса.Адрес + ":" + СтрокаПорт + " отсутствует в списке настроенных серверов кластера 1С. Список серверов кластера 1С можется быть настроен только в ручном режиме");
			Возврат Ложь;
		КонецЕсли;
		
	Иначе
		
		Возврат Истина;
		
	КонецЕсли;
	
КонецФункции

&НаСервере
Процедура ПроверитьЭкземплярИнформационнойБазыДляФормыКонстант() Экспорт
	  
	Если сшпОбщегоНазначения.ПроверитьЭкземплярИнформационнойБазы() Тогда
		 
    	Сообщение = Новый СообщениеПользователю();
		Сообщение.Текст = "Проверка выполнения успешно";
		Сообщение.Сообщить();
	
	КонецЕсли;

КонецПроцедуры

&НаСервере
// Функция - ПолучитьКлючЗаписиПоСтрокеПоиска
// 
// Возвращаемое значение:
// КлючЗаписи, Строка - ключ записи - если запись найдена, строка - текст ошибки.
//
Функция ПолучитьКлючЗаписиПоСтрокеПоиска(ОбработчикОчереди, СтрокаПоиска) Экспорт 
	
	Попытка
		
		ИдентификаторСообщения = Новый УникальныйИдентификатор(СтрокаПоиска);
	
	Исключение
		
		Возврат "Для поиска требуется ввести в строке уникальный идентификатор сообщения полностью";
	
	КонецПопытки;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	сшпОчередьСообщений.ИдентификаторСобытия
		|ИЗ
		|	РегистрСведений."+ ОбработчикОчереди + " КАК сшпОчередьСообщений
		|ГДЕ
		|	сшпОчередьСообщений.ИдентификаторСобытия = &ИдентификаторСобытия";	
	Запрос.УстановитьПараметр("ИдентификаторСобытия", ИдентификаторСообщения);
	
	РезультатЗапроса = Запрос.Выполнить();

	Если РезультатЗапроса.Пустой() Тогда
		 
		Возврат "Сообщение не найдено";
		
	Иначе
		
		Возврат РегистрыСведений[ОбработчикОчереди].СоздатьКлючЗаписи(Новый Структура("ИдентификаторСобытия", ИдентификаторСообщения));
		
	КонецЕсли;
	
КонецФункции

#КонецЕсли

// Функция - Получить параметры сообщения структурой
//
// Параметры:
//  Сообщение - ОбъектXDTO - объект типа Message1C 
// 
// Возвращаемое значение:
//  Структура - структура с дополнительными свойствами сообщения.
//
функция ПолучитьПараметрыСообщенияСтруктурой(Сообщение) Экспорт
	
	СтруктураПараметры = Новый Структура;
	Если Не Сообщение = Неопределено Тогда
		
		xdtoСвойства = Сообщение.Properties.Последовательность();
		
		Если xdtoСвойства = Неопределено тогда // В зависимости от вида сериализации это может быть список или последовательность.
			
			xdtoСвойства = Сообщение.Properties.ПолучитьСписок("MessageProperty");
			
			Для Каждого текПараметр Из xdtoСвойства Цикл
				
				СтруктураПараметры.Вставить(текПараметр.Name, ПолучитьЗначениеСвойстваСообщения(текПараметр));
				 
			КонецЦикла;
			
		Иначе
			 	
			КоличествоПараметры = xdtoСвойства.Количество();
					
			Если КоличествоПараметры > 0 Тогда
				
				Для Индекс = 0 По количествоПараметры - 1 Цикл
					
					текПараметр = xdtoСвойства.ПолучитьЗначениеXDTO(Индекс);
					структураПараметры.Вставить(текПараметр.Name, ПолучитьЗначениеСвойстваСообщения(текПараметр)); 
				
				КонецЦикла;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат СтруктураПараметры;
	
КонецФункции

// Функция - Получить значение свойства сообщения
//
// Параметры:
//  свойство - ОбъектXDTO - свойство сообщения
// 
// Возвращаемое значение:
//  Любое значение - значение свойства сообщения 
//
Функция ПолучитьЗначениеСвойстваСообщения(Свойство)
	
	типСвойства = Свойство.Получить("Value/Type");
	типСвойства = ?(типСвойства = "Double", "Boolean", типСвойства);
	
	типСвойства1С = ?(НРег(типСвойства) = "integer", "Number", типСвойства);
	 
	Узел = Свойство.Получить("Value/"+типСвойства+"Values/");
	
	ЗначениеСвойства = Узел.Получить(Узел.Свойства().Get(0).Имя);
	
	Возврат ?(ЗначениеСвойства = null или ЗначениеСвойства = Неопределено, Неопределено, XMLЗначение(Тип(типСвойства1С), ЗначениеСвойства));

КонецФункции

// Процедура - Запустить обработчик очереди
//
// Параметры:
//  обработчикочереди - Строка - имя функции обработчика.
//  имямодуля - Строка - имя модуля в котором размещена функция обработчик.
//
Процедура ЗапуститьОбработчикОчереди(ОбработчикОчереди, ИмяМодуля = "сшпОбслуживаниеОчередей") Экспорт
		
		Попытка
			
			ФоновыеЗадания.Выполнить(ИмяМодуля + "." + ОбработчикОчереди,, ОбработчикОчереди, ОбработчикОчереди);
		
		Исключение
			// Запускаем фоновое задание со статическим ключем. Запуск других экземпляров должен заканчиваться ошибкой (паттерн синглтон).
		КонецПопытки;
		
КонецПроцедуры

// Функция - Получить параметры сообщения структурой
//
// Параметры:
//  Сообщение - ПакетXML - Строка, содержащая XML. Ожидаемая схема XML - Message 
// 
// Возвращаемое значение:
//  Структура - структура с дополнительными свойствами сообщения.
//
функция ПолучитьПараметрыСообщенияСтруктуройПоПакетуXML(ПакетXML) Экспорт
	
	xdtoТип 				= ФабрикаXDTO.Тип("http://esb.axelot.ru", "Message");
	ПакетXDTO 				= сшпОбщегоНазначения.ПолучитьОбъектXDTO(Перечисления.сшпФорматыСообщений.XML, ПакетXML, xdtoТип);
	
	Возврат ПолучитьПараметрыСообщенияСтруктурой(ПакетXDTO);

КонецФункции

// Процедура - Установить свойства адаптера Pipe
//
// Параметры:
//  ИДАдаптера - Строка - Идентификатор адаптера 
//	ИмяАдаптера - Строка - Имя адаптера
// 
Процедура УстановитьСвойстваАдаптераPipe(ИДАдаптера, ИмяАдаптера) Экспорт
	
	ПараметрыИзменены = Ложь;
	
	Если Не Константы.сшпИДАдаптера.Получить() = ИДАдаптера Тогда
		
		Константы.сшпИДАдаптера.Установить(ИДАдаптера);
		ПараметрыИзменены = Истина;
		
	КонецЕсли;
	
	Если Не Константы.сшпИмяАдаптера.Получить() = ИмяАдаптера Тогда
		
		Константы.сшпИмяАдаптера.Установить(ИмяАдаптера);
		ПараметрыИзменены = Истина;
		
	КонецЕсли;
	
	Если Не сшпФункциональныеОпции.ТипИспользуемогоКоннектораESB() = Перечисления.сшпТипыКоннекторовESB.Pipe Тогда
		
		#Если ВнешнееСоединение тогда
		сшпВызовСервера.УстановитьЗначениеКонстанты("сшпТипИспользуемогоКоннектораESB", Перечисления.сшпТипыКоннекторовESB.Pipe);	
		#Иначе	
		сшпРаботаСКонстантами.УстановитьЗначениеКонстанты("сшпТипИспользуемогоКоннектораESB", Перечисления.сшпТипыКоннекторовESB.Pipe);
		#КонецЕсли 
		ПараметрыИзменены = Истина;
		
	КонецЕсли;
		
	Если ПараметрыИзменены Тогда
		 
		ОбновитьПовторноИспользуемыеЗначения();
		сшпОбщегоНазначения.УстановитьНовуюВерсиюПараметровПодсистемы();
		
	КонецЕсли;
	
КонецПроцедуры

// Процедура - Зарегистрировать запись в журнале
//
// Параметры:
//  Уровень - УровеньЖурналаРегистрации - Уровень записи журнала 
//	Заголовок - Строка - Заголовок записи
//	ТекстСообщения -  Строка - Текс сообщения
//  +++ Градум; Кульчихин; 28.06.2021; №B21877. В процедуру добавлен новый необязательный параметр грДанные
//Процедура ЗарегистрироватьЗаписьВЖурнале(Уровень, Заголовок, ТекстСообщения) Экспорт
Процедура ЗарегистрироватьЗаписьВЖурнале(Уровень, Заголовок, ТекстСообщения, грДанные = Неопределено) Экспорт
//  --- Градум; Кульчихин; 28.06.2021; №B21877. В процедуру добавлен новый необязательный параметр грДанные
	 
	Если ЗначениеЗаполнено(Заголовок) Тогда
		//  +++ Градум; Кульчихин; 28.06.2021; №B21877
		//ЗаписьЖурналаРегистрации(Заголовок, Уровень, , , ТекстСообщения);
		ЗаписьЖурналаРегистрации(Заголовок, Уровень, , грДанные, ТекстСообщения);
		//  --- Градум; Кульчихин; 28.06.2021; №B21877
	КонецЕсли;
	
	Если сшпФункциональныеОпции.ТипИспользуемогоКоннектораESB() = Перечисления.сшпТипыКоннекторовESB.Pipe Тогда

		Попытка

			Если Уровень = УровеньЖурналаРегистрации.Ошибка Тогда

				#Если ВнешнееСоединение тогда
				сшпВызовСервера.сшпPipeУстановитьСоединениеИЗарегистрироватьОшибку(ТекстСообщения);
				#Иначе	
				сшпPipe.УстановитьСоединениеИЗарегистрироватьОшибку(ТекстСообщения);
				#КонецЕсли 

			ИначеЕсли Уровень = УровеньЖурналаРегистрации.Предупреждение Тогда

				#Если ВнешнееСоединение тогда
				сшпВызовСервера.сшпPipeУстановитьСоединениеИЗарегистрироватьПредупреждение(ТекстСообщения);
				#Иначе	
				сшпPipe.УстановитьСоединениеИЗарегистрироватьПредупреждение(ТекстСообщения);
				#КонецЕсли 

			ИначеЕсли Уровень = УровеньЖурналаРегистрации.Информация Тогда

				#Если ВнешнееСоединение тогда
				сшпВызовСервера.сшпPipeУстановитьСоединениеИЗарегистрироватьИнформационноеСообщение(ТекстСообщения);
				#Иначе	
				сшпPipe.УстановитьСоединениеИЗарегистрироватьИнформационноеСообщение(ТекстСообщения);
				#КонецЕсли 

			Иначе

				#Если ВнешнееСоединение тогда
				сшпВызовСервера.сшпPipeУстановитьСоединениеИЗарегистрироватьОтладочноеСообщение(ТекстСообщения);
				#Иначе	
				сшпPipe.УстановитьСоединениеИЗарегистрироватьОтладочноеСообщение(ТекстСообщения);
				#КонецЕсли 

			КонецЕсли;

		Исключение

			ТекстОшибки = ПодробноеПредставлениеОшибки(ОписаниеОшибки());
			ЗаписьЖурналаРегистрации("Datareon.Передача служебной информации в адаптер", УровеньЖурналаРегистрации.Ошибка, , , ТекстОшибки);

		КонецПопытки;

	ИначеЕсли сшпФункциональныеОпции.ТипИспользуемогоКоннектораESB() = Перечисления.сшпТипыКоннекторовESB.Tcp Тогда

		Попытка

			Если Уровень = УровеньЖурналаРегистрации.Ошибка Тогда

				#Если ВнешнееСоединение тогда
				сшпВызовСервера.сшпTcpУстановитьСоединениеИЗарегистрироватьОшибку(ТекстСообщения);
				#Иначе	
				сшпTcp.УстановитьСоединениеИЗарегистрироватьОшибку(ТекстСообщения);
				#КонецЕсли 

			ИначеЕсли Уровень = УровеньЖурналаРегистрации.Предупреждение Тогда

				#Если ВнешнееСоединение тогда
				сшпВызовСервера.сшпTcpУстановитьСоединениеИЗарегистрироватьПредупреждение(ТекстСообщения);
				#Иначе	
				сшпTcp.УстановитьСоединениеИЗарегистрироватьПредупреждение(ТекстСообщения);
				#КонецЕсли 
				
			ИначеЕсли Уровень = УровеньЖурналаРегистрации.Информация Тогда

				#Если ВнешнееСоединение тогда
				сшпВызовСервера.сшпTcpУстановитьСоединениеИЗарегистрироватьИнформационноеСообщение(ТекстСообщения);
				#Иначе	
				сшпTcp.УстановитьСоединениеИЗарегистрироватьИнформационноеСообщение(ТекстСообщения);
				#КонецЕсли 

			Иначе

				#Если ВнешнееСоединение тогда
				сшпВызовСервера.сшпTcpУстановитьСоединениеИЗарегистрироватьОтладочноеСообщение(ТекстСообщения);
				#Иначе	
				сшпTcp.УстановитьСоединениеИЗарегистрироватьОтладочноеСообщение(ТекстСообщения);
				#КонецЕсли 
				
			КонецЕсли;

		Исключение

			ТекстОшибки = ПодробноеПредставлениеОшибки(ОписаниеОшибки());
			ЗаписьЖурналаРегистрации("Datareon.Передача служебной информации в адаптер", УровеньЖурналаРегистрации.Ошибка, , , ТекстОшибки);

		КонецПопытки;

	Иначе

		Попытка

			Если Уровень = УровеньЖурналаРегистрации.Ошибка Тогда

				#Если ВнешнееСоединение тогда
				сшпВызовСервера.ЗарегистрироватьОшибку(ТекстСообщения);
				#Иначе	
				сшпВзаимодействиеСАдаптером.ЗарегистрироватьОшибку(ТекстСообщения);
				#КонецЕсли 

			ИначеЕсли Уровень = УровеньЖурналаРегистрации.Предупреждение Тогда

				#Если ВнешнееСоединение тогда
				сшпВызовСервера.ЗарегистрироватьПредупреждение(ТекстСообщения);
				#Иначе	
				сшпВзаимодействиеСАдаптером.ЗарегистрироватьПредупреждение(ТекстСообщения);
				#КонецЕсли 

			ИначеЕсли Уровень = УровеньЖурналаРегистрации.Информация Тогда

				#Если ВнешнееСоединение тогда
				сшпВызовСервера.ЗарегистрироватьИнформационноеСообщение(ТекстСообщения);
				#Иначе	
				сшпВзаимодействиеСАдаптером.ЗарегистрироватьИнформационноеСообщение(ТекстСообщения);
				#КонецЕсли 

			Иначе

				#Если ВнешнееСоединение тогда
				сшпВызовСервера.ЗарегистрироватьОтладочноеСообщение(ТекстСообщения);
				#Иначе	
				сшпВзаимодействиеСАдаптером.ЗарегистрироватьОтладочноеСообщение(ТекстСообщения);
				#КонецЕсли 

			КонецЕсли;

		Исключение

			ТекстОшибки = ПодробноеПредставлениеОшибки(ОписаниеОшибки());
			ЗаписьЖурналаРегистрации("Datareon.Передача служебной информации в адаптер", УровеньЖурналаРегистрации.Ошибка, , , ТекстОшибки);

		КонецПопытки;

	КонецЕсли;
	
КонецПроцедуры

// Процедура - Установить новую версию параметров подсистемы
// 
Процедура УстановитьНовуюВерсиюПараметровПодсистемы() Экспорт
	 
	Константы.сшпВерсияПараметровПодсистемы.Установить(Новый УникальныйИдентификатор());

КонецПроцедуры

// Процедура - Параметры подсистемы обновлены
//
// Параметры:
//  ВерсияПараметровПодсистемы - УникальныйИдентификатор - версия параметров подсистемы
// 	
Функция ПараметрыПодсистемыОбновлены(ВерсияПараметровПодсистемы) Экспорт 
	
	НовоеЗначениеКонстанты = ПолучитьФункциональнуюОпцию("сшпВерсияПараметровПодсистемы");
	
	Если НовоеЗначениеКонстанты = ВерсияПараметровПодсистемы Тогда 
		
		Возврат Ложь;
	
	Иначе
		
		ВерсияПараметровПодсистемы = НовоеЗначениеКонстанты;
		
		Возврат Истина;
	
	КонецЕсли;
	
КонецФункции

// Функция - Получить текст ошибки обработчика
//
// Параметры:
//	ОшибкаОбработчика - ИнформацияОбОшибке - результат функции ИнформацияОбОшибке()
//
Функция ПолучитьТекстОшибкиОбработчика(Знач ОшибкаОбработчика) Экспорт
	
	Если ТипЗнч(ОшибкаОбработчика.Причина) = Тип("ИнформацияОбОшибке") Тогда
	
		Возврат "Не удалось обработать сообщение " + ПодробноеПредставлениеОшибки(ОшибкаОбработчика.Причина);
			
	Иначе
		
		Возврат "Не удалось обработать сообщение " + ПодробноеПредставлениеОшибки(ОшибкаОбработчика);
		
	КонецЕсли;
	
КонецФункции

// Процедура - Установить свойства адаптера Tcp
//
// Параметры:
//  ИДАдаптера - Строка - Идентификатор адаптера 
//	ИмяАдаптера - Строка - Имя адаптера
// 
Процедура УстановитьСвойстваАдаптераTcp(АдресСервера, Порт, ИмяАдаптера, Ключ) Экспорт
	
	ПараметрыИзменены = Ложь;
	
	Если Не Константы.сшпАдресTcpСервера.Получить() = АдресСервера Тогда
		
		Константы.сшпАдресTcpСервера.Установить(АдресСервера);
		ПараметрыИзменены = Истина;
		
	КонецЕсли;
		
	Если Не Константы.сшпПортTcpСервера.Получить() = Порт Тогда
		
		#Если ВнешнееСоединение тогда
		сшпВызовСервера.УстановитьЗначениеКонстанты("сшпПортTcpСервера", Порт);
		#Иначе	
		сшпРаботаСКонстантами.УстановитьЗначениеКонстанты("сшпПортTcpСервера", Порт);
		#КонецЕсли 
		
	КонецЕсли;
	
	Если Не Константы.сшпИмяАдаптера.Получить() = ИмяАдаптера Тогда
		
		#Если ВнешнееСоединение тогда
		сшпВызовСервера.УстановитьЗначениеКонстанты("сшпИмяАдаптера", ИмяАдаптера);
		#Иначе	
		сшпРаботаСКонстантами.УстановитьЗначениеКонстанты("сшпИмяАдаптера", ИмяАдаптера);
		#КонецЕсли 
		
	КонецЕсли;
	
	Если Не Константы.сшпКлючTcp.Получить() = Ключ Тогда
		
		#Если ВнешнееСоединение тогда
		сшпВызовСервера.УстановитьЗначениеКонстанты("сшпКлючTcp", Ключ);
		#Иначе	
		сшпРаботаСКонстантами.УстановитьЗначениеКонстанты("сшпКлючTcp", Ключ);
		#КонецЕсли 
		
	КонецЕсли;
	
	Если Не сшпФункциональныеОпции.ТипИспользуемогоКоннектораESB() = Перечисления.сшпТипыКоннекторовESB.Tcp Тогда
		 
		#Если ВнешнееСоединение тогда
		сшпВызовСервера.УстановитьЗначениеКонстанты("сшпТипИспользуемогоКоннектораESB", Перечисления.сшпТипыКоннекторовESB.Tcp);
		#Иначе	
		сшпРаботаСКонстантами.УстановитьЗначениеКонстанты("сшпТипИспользуемогоКоннектораESB", Перечисления.сшпТипыКоннекторовESB.Tcp);
		#КонецЕсли 
		ПараметрыИзменены = Истина;
		
	КонецЕсли;
		
	Если ПараметрыИзменены Тогда
		 
		ОбновитьПовторноИспользуемыеЗначения();
		сшпОбщегоНазначения.УстановитьНовуюВерсиюПараметровПодсистемы();
		
	КонецЕсли;
	
КонецПроцедуры

// Процедура - Запустить обработчики Pipe и Tcp
// 
Процедура ЗапуститьОбработчикиPipeTcp() Экспорт
	
	#Если ВнешнееСоединение тогда
	сшпВызовСервера.сшпPipeЗапуститьОбработчики();
	
	сшпВызовСервера.сшпTcpЗапуститьОбработчики();
	#Иначе	
	сшпPipe.ЗапуститьОбработчики();
	
	сшпTcp.ЗапуститьОбработчики();
	#КонецЕсли 
	
КонецПроцедуры

// Процедура - Установить свойство поиска 
// 
// Параметры:
// 	ОбъектСобытия - ЛюбаяСсылка - Передаваемый объект
// 	РезультатОбработки - Структура - Результат обработки исходящего сообщения
//
Процедура УстановитьСвойствоПоиска(ОбъектСобытия, РезультатОбработки) Экспорт
	
	Если Не ТипЗнч(ОбъектСобытия) = Тип("Отбор") И 
		Не ТипЗнч(ОбъектСобытия) = Тип("Структура") И 
		Не ТипЗнч(ОбъектСобытия) = Тип("Строка") И
		Не ОбъектСобытия = Неопределено Тогда
		
		Попытка
		
			Если РезультатОбработки.Properties = Неопределено Тогда
				
				РезультатОбработки.Properties = Новый Структура();
							
			КонецЕсли;
			
			РезультатОбработки.Properties.Вставить("EntityId", Строка(ОбъектСобытия.Ссылка.УникальныйИдентификатор()));
			
		Исключение
			
			ЗаписьЖурналаРегистрации("Datareon. Установка свойства для поиска объекта", УровеньЖурналаРегистрации.Ошибка, , , "Не удалось установить свойство для поиска объекта, по причине: " + ОписаниеОшибки());
			
		КонецПопытки;
		
	КонецЕсли;
	
КонецПроцедуры

// Функция - Заменить специальные символы 
// 
// Параметры:
// 	СтрокаТекста - Строка - строка текста
// 	
// Возвращаемое значение:
//  Строка - строка текста
//
Функция ЗаменитьСпециальныеСимволы(СтрокаТекста)
	
	Результат = СтрЗаменить(СтрокаТекста, "&", "&amp;");
	Результат = СтрЗаменить(Результат, """", "&quot;");
	Результат = СтрЗаменить(Результат, "<", "&lt;");
	Результат = СтрЗаменить(Результат, ">", "&gt;");
	Результат = СтрЗаменить(Результат, "'", "&apos;");
	
	Возврат Результат;
	
КонецФункции

// Функция - Получить количество попыток ожидания 
// 
// Параметры:
// 	ОбъектСообщение - ОбъектXDTO - Объект сообщения
// 	
// Возвращаемое значение:
//  Число - значение дополнительного свойства "DelayCount"
//
Функция ПолучитьКоличествоПопытокОжидания(ОбъектСообщение) Экспорт
	
	КоличествоПопытокОжидания = 0;
	
	Если Не ОбъектСообщение.Properties = Неопределено Тогда

		СтруктураСвойств = сшпОбщегоНазначения.ПолучитьПараметрыСообщенияСтруктурой(ОбъектСообщение);
		
		Если Не СтруктураСвойств.Свойство("DelayCount", КоличествоПопытокОжидания) Тогда
			КоличествоПопытокОжидания = 0;
		КонецЕсли;
			
	КонецЕсли;
		
	Возврат КоличествоПопытокОжидания;
		
КонецФункции

// Функция - Дополнить текст ошибки 
// 
// Параметры:
// 	ТекстОшибки - Строка - Исходный текст ошибки
//	Обработчик - Структура - Структура описания обработчика
//	Объект - ЛюбаяСсылка - Объект ошибки
// 	
// Возвращаемое значение:
//  Строка - Дополненный текст ошибки
//
Функция ДополнитьТекстОшибки(ТекстОшибки, Обработчик, Объект) Экспорт
		
	Если ЗначениеЗаполнено(Объект) Тогда
		ТекстОбъекта = ", объект: " + Строка(Объект) + "/" + Объект.УникальныйИдентификатор();
	Иначе
		ТекстОбъекта = "";
	КонецЕсли;
		
	ТекстОшибки = "При выполнении обработчика " + Обработчик.Наименование + " [Версия: " + Обработчик.Версия + ТекстОбъекта + "]" + " произошла ошибка: " + ТекстОшибки;
	
	Возврат ТекстОшибки;
	
КонецФункции

// Функция - Получить статус события
// 
// Параметры:
// 	ИдентификаторСобытия - УникальныйИдентификатор - Идентификатор события
// Возвращаемое значение:
// 	Перечисление.сшпСтатусыСообщений - Статус события
Функция ПолучитьСтатусСобытия(ИдентификаторСобытия) Экспорт
	
	Запрос = Новый Запрос();
	Запрос.Текст = "ВЫБРАТЬ
	|	сшпСостояниеСообщений.СтатусСообщения
	|ИЗ
	|	РегистрСведений.сшпСостояниеСообщений КАК сшпСостояниеСообщений
	|ГДЕ
	|	сшпСостояниеСообщений.ИдентификаторСобытия = &ИдентификаторСобытия";
	Запрос.УстановитьПараметр("ИдентификаторСобытия", ИдентификаторСобытия);
	
	Результат = Запрос.Выполнить().Выбрать();
	
	Если Результат.Следующий() Тогда
		Возврат Результат.СтатусСообщения;
	Иначе
		Возврат Неопределено;
	КонецЕсли;	
	
КонецФункции

// Функция - выполнение подготовленной функции
//
//Параметры:
//	ИмяФункции - Строка - Имя выполняемой функции, соотвествующее наименованию объекта интеграции
//	ТекстФункции - Строка - Подготовленный текст выполняемой функции
//	ПараметрыФункции - Структура - Структура параметров функции, ключи структуры должны соответствовать именам переменных функции
//
//Возвращаемое значение:
//	ЛюбоеЗначение - Возвращаемое значение зависит от вызываемой функции из объектов интеграции 
Функция ВыполнитьНеКешируемуюФункцию(ИмяФункции, ТекстФункции, ПараметрыФункции)
	
	Результат = Неопределено;
	
	Попытка
		Выполнить(ТекстФункции);
	Исключение
		#Если ВнешнееСоединение тогда
		сшпВызовСервера.ОтправитьСообщениеОбОшибке("Выполнение функции " + ИмяФункции, "При выполнении функции была обнаружена ошибка, " + ОписаниеОшибки(), Новый Структура());
		#Иначе	
		сшпСистемныеСообщения.ОтправитьСообщениеОбОшибке("Выполнение функции " + ИмяФункции, "При выполнении функции была обнаружена ошибка, " + ОписаниеОшибки(), Новый Структура());
		#КонецЕсли 
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Функция - поиск и подготовка функции к выполнению
//
//Параметры:
//	ИмяФункции - Строка - Имя выполняемой функции, соотвествующее наименованию объекта интеграции
//	ПараметрыФункции - Структура - Структура параметров функции, ключи структуры должны соответствовать именам переменных функции
//	Кэшированная - Булево - Использовать кэшированную функцию
//
//Возвращаемое значение:
//	ЛюбоеЗначение - Возвращаемое значение зависит от вызываемой функции из объектов интеграции
Функция ВыполнитьФункцию(ИмяФункции, ПараметрыФункции, Кэшированная = Ложь) Экспорт
	
	//Находим функцию
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	               |	сшпРепозиторийОбъектовИнтеграции.ПроцедураОбработки КАК ПроцедураОбработки
	               |ИЗ
	               |	РегистрСведений.сшпРепозиторийОбъектовИнтеграции КАК сшпРепозиторийОбъектовИнтеграции
	               |		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.сшпСтатусыОбработчиков КАК сшпСтатусыОбработчиков
	               |		ПО сшпРепозиторийОбъектовИнтеграции.ИдентификаторШаблона = сшпСтатусыОбработчиков.ИдентификаторОбработчика
	               |ГДЕ
	               |	сшпРепозиторийОбъектовИнтеграции.ТипИнтеграции = ЗНАЧЕНИЕ(Перечисление.сшпТипыИнтеграции.Функция)
	               |	И сшпРепозиторийОбъектовИнтеграции.Наименование = &Наименование
	               |	И сшпСтатусыОбработчиков.Статус = ЗНАЧЕНИЕ(Перечисление.сшпСтатусыОбработчиков.Включен)";
	Запрос.УстановитьПараметр("Наименование", ИмяФункции);
	
	Результат = Запрос.Выполнить().Выбрать();
	Если Результат.Следующий() Тогда
		
		ТекстФункции = Результат.ПроцедураОбработки;
		
		//Заменяем переменные типа ~<ИмяПеременной>: на ПараметрыФункции.<ИмяПеременной>
		Для Каждого СтрокаПараметров Из ПараметрыФункции Цикл
			
			ТекстФункции = СтрЗаменить(ТекстФункции, "~" + СтрокаПараметров.Ключ + ":", "ПараметрыФункции." + СтрокаПараметров.Ключ);
			
		КонецЦикла;
		
		Если Кэшированная Тогда
		    Возврат сшпКэшируемыеФункции.ВыполнитьКешируемуюФункцию(ИмяФункции, ТекстФункции, ПараметрыФункции);
		Иначе
			Возврат ВыполнитьНеКешируемуюФункцию(ИмяФункции, ТекстФункции, ПараметрыФункции);
		КонецЕсли;
		
	Иначе
		
		#Если ВнешнееСоединение тогда
		сшпВызовСервера.ОтправитьСообщениеОбОшибке(ИмяФункции, "Не найдена или отключена функция " + ИмяФункции + " будет возвращено Неопределено", Новый Структура());
		#Иначе	
		сшпСистемныеСообщения.ОтправитьСообщениеОбОшибке(ИмяФункции, "Не найдена или отключена функция " + ИмяФункции + " будет возвращено Неопределено", Новый Структура());
		#КонецЕсли 
		
		Возврат Неопределено;
		
	КонецЕсли;
	
КонецФункции

// Функция - Получает структуру описания обработчика
// 
// Возвращаемое значение:
// 	Структура - Структура описания обработчика
//
Функция ПолучитьСтруктуруОписанияОбработчика() Экспорт
	Возврат Новый Структура("ОбработчикНайден, Отключен, Наименование, ПроцедураОбработки, ИдентификаторШаблона, Версия, Статус", Ложь, Истина);
КонецФункции

// Функция - Получает таблицу адресов менеджеров узлов
//
// Возвращаемое значение:
// 	ТаблицаЗначений - таблицу адресов менеджеров узлов
//
Функция ПолучитьАдресаМенеджеровУзлов() Экспорт
	
	АдресаМенеджеровУзлов = Константы.сшпАдресаМенеджеровУзлов.Получить().Получить();
	
	Если ТипЗнч(АдресаМенеджеровУзлов) <> Тип("Структура") тогда
		Адреса = Новый ТаблицаЗначений;
		Адреса.Колонки.Добавить("Адрес", Новый ОписаниеТипов("Строка"));
		Адреса.Колонки.Добавить("Порт", Новый ОписаниеТипов("Строка"));
		Адреса.Колонки.Добавить("ДобавленоВручную", Новый ОписаниеТипов("Булево"));
		Адреса.Колонки.Добавить("СчетчикПопытокПодключения", Новый ОписаниеТипов("Число"));
			
		АдресаМенеджеровУзлов = АдресаМенеджеровУзлов(Адреса, 0);
	КонецЕсли;	
	
	Возврат АдресаМенеджеровУзлов;
	
КонецФункции	

// Процедура - добавляет адрес менеджера узла в таблицу АдресаМенеджеровУзлов 
// 
// Параметры:
// 	АдресаМенеджеровУзлов - ТаблицаЗначений - таблицу адресов менеджеров узлов
// 	Адрес - Строка - адрес менеджера узла
// 	Порт - Строка - порт менеджера узла
// 	СброситьСчетчикПопыток - Булево - признак необходимости сброса счетчика попыток подключения для найденного адреса
//
Процедура ДобавитьАдресМенеджераУзла(АдресаМенеджеровУзлов, Знач Адрес, Знач Порт, СброситьСчетчикПопыток = Истина) Экспорт
	
	Адрес = ВРег(Адрес);
	
	Отбор = Новый Структура("Адрес,Порт", Адрес, Порт);
	
	НайденныеСтроки = АдресаМенеджеровУзлов.НайтиСтроки(Отбор);
	Если НайденныеСтроки.Количество() = 0 тогда
		
		НоваяСтрока = АдресаМенеджеровУзлов.Добавить();
		НоваяСтрока.Адрес = Адрес;
		НоваяСтрока.Порт = Порт;
		
	ИначеЕсли СброситьСчетчикПопыток тогда 
		
		НайденныеСтроки[0].СчетчикПопытокПодключения = 0;
		
	КонецЕсли;	
	
КонецПроцедуры

// Процедура - записывает в константу таблицу адресов менеджеров узлов 
// 
// Параметры:
// 	АдресаМенеджеровУзлов - ТаблицаЗначений - таблицу адресов менеджеров узлов
//
Процедура СохранитьАдресаМенеджеровУзлов(Адреса, Версия = Неопределено) Экспорт
	
	Если Версия <> Неопределено И ПолучитьАдресаМенеджеровУзлов().Версия <> Версия тогда
		Возврат
	КонецЕсли;	
	
	АдресаМенеджеровУзлов = АдресаМенеджеровУзлов(Адреса, ТекущаяУниверсальнаяДатаВМиллисекундах());	
	
	Константы.сшпАдресаМенеджеровУзлов.Установить(Новый ХранилищеЗначения(АдресаМенеджеровУзлов));	
	
КонецПроцедуры

// Функция - получение структуры адресов менеджеров узлов
//
// Параметры:
//	Адреса - ТаблицаЗначений - таблица адресов менеджеров узлов
//  Версия - Число - универсальная дата в миллисекундах
//
// Возвращаемое значение:
// 	Структура - структура адресов менеджеров узлов
//
Функция АдресаМенеджеровУзлов(Адреса, Версия)
	
	Результат = Новый Структура;
	Результат.Вставить("Версия", Версия);
	Результат.Вставить("Адреса", Адреса);
	
	Возврат Результат; 
	
КонецФункции	

#КонецОбласти
